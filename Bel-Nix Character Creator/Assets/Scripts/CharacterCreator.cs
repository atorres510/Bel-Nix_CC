using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;
using System.IO;



public class CharacterCreator : MonoBehaviour {

    public Token currentToken;
    Token previousToken;
    
    bool isClothingPersistent = true;

    /*public Token dwarfToken;
    public Token humanToken;
    public Token halfelfToken;
    public Token elfToken;
    public Token dragonbornToken;
    public Token halforcToken;
    public Token halflingToken;
    public Token gnomeToken;
    public Token tieflingToken;*/

    public SpriteLibrary spriteLibrary;
    public Renderer activeRenderer;
    public GameObject gridObject;
    public GameObject presetsObject;
    public Sprite blankUISprite;

    public Sprite blankSprite;

    public ColorPicker picker;
    public Image emptyImage;
    public Button emptyButton;
    Image lastSelectedLayer;
    Color layerColor;
    Button lastSelectedButton;
  
    Image skinLayer;
    Color skinColor;

    //Button grid variables
    Button[] buttonGrid;
    int currentbuttonGridLength = 0;

    public GameObject canvasBackgroundObject;

    string exportName;

    public GameObject paperDoll;
    Image[] paperDollLayers;
    Image[] paperDollClothingLayers;
    Image[] paperDollHandLayers;
    Image[] paperDollEquipmentLayers;

    string[] subLayers = {"Clothing", "Hands", "Equipment"};
    public Image[] skinLayers;

    public int activeLayer; //layer based on the paperdoll order
 
    // informs the current race of the token.  this value is changed by the buttons in the RaceButtonList UI
    //determines presets, size, and raceType.  
    public int raceID = 2; //default race is human.
    // 1: Dwarf, 2: Human, 3: Half-elf
    // 4: Elf, 5: Dragonborn, 6: Half-Orc
    // 7: Halfling, 8: Gnome, 9: tiefling
    //add more races here!!
    
    int chestType = 0; //0 none, 1 Acup, 2 Bcup
    int size = 0; //0 medium, 1 small
    int raceType = 0;   //0 Base, 1 Dragonborn, 2 tiefling
    int bodyType = 1; // 0 Bony, 1 Fit
    int accessoryType = 0; // 0 backitem, 1, handitem, 2, helmetitem, 3 shoulderitems, 4 capeitems

    //the rest of these ints simply correspond to the sprite in order of where they are in the grid (or sprite[] generated by the library)
    int hairSprite = 1;
    int capeSprite = 0; 
    int backSprite = 0;
    int shoulderSprite = 0;
    int helmetSprite = 0;
    int racialSprite = 0;


    //arrays of strings that are used to construct the keys needed to GetSprites or FillButtons.  Used by ConstructKey
    //these will need to be in alphabetical order because that is how the folders are ordered.
    string headString = "Base";
    string[] sexStrings = { "F", "M" };
    string[] sizeStrings = { "Med", "Sm" };
    string[] bodyStrings = { "Bony", "Fit", "Stout", "Thick", "Buff"};
    string[] raceStrings = { "Base", "Dragonborn", "Tiefling" };
    string[] accessoryStrings = { "BackItems", "HandItems", "HelmetItems", "ShoulderItems", "CapeItems", "ScarfItems" };

    //Stores Keys
    string bodyTypeKey;
    string clothingTypeKey;
    string accessoryTypeKey;
    string hairTypeKey;
    
    #region Sprite Key Methods
    
    //takes all of the featureString variables and uses them to construct a specific key and returns it as a string for use by GetSprite or FillButton
    string ConstructKey(string keyType) {

        string key = "";

        keyType = keyType.ToUpper();

        //Debug.Log(keyType);

        switch (keyType) {

            case "BODYTYPEKEY":

                key = sizeStrings[size] + "_" + raceStrings[raceType] + "_bodyType";

                break;

            case "CHESTTYPEKEY":

                key = sizeStrings[size] + "_" + bodyStrings[bodyType] + "_chestType";

                break;

            case "CLOTHINGTYPEKEY":

                key = sizeStrings[size] + "_" + bodyStrings[bodyType] + /*chesttype*/ "_clothingType";

                break;

            case "BACKTYPEKEY":

                key = sizeStrings[size] + "_backType";

                break;

            case "HEADTYPEKEY":

                key = sizeStrings[size] + "_" + headString + "_headType";

                break;

            case "HAIRTYPEKEY":

                key = sizeStrings[size] + "_" + raceStrings[raceType] + "_hairType";

                break;

            case "HANDTYPEKEY":

                key = sizeStrings[size] + "_" + raceStrings[raceType] + "_" + bodyStrings[bodyType] +"_handType";

                break;

            case "CAPETYPEKEY":

                key = sizeStrings[size] + "_capeType";

                break;

            case "SHOULDERTYPEKEY":

                key = sizeStrings[size] + "_shoulderType";

                break;

            case "HELMETTYPEKEY":

                key = sizeStrings[size] + "_" + raceStrings[raceType] + "_helmetType";

                break;

            case "EQUIPMENTTYPEKEY":

                key = sizeStrings[size] + "_EquipmentType";

                break;


            case "RACIALFEATUREKEY":

                key = raceStrings[raceType] + "_racialFeatures";

                break;
                
            default:
                Debug.Log("Defaulting ConstructKey()");
                break;

        }

        key = key.ToUpper();

        //Debug.Log(key);

        return key;

    }

    #endregion

    #region Layer and SubLayer Methods
    //the layer and sublayer methods are for UI use to set active layers and to fill the grid buttons with the appropriate sprites for use.  

    //For use of the UI to determine what layer of the paperdoll is currently being edited, and to fill the buttons with the appropriate sprites for player's selection
    public void SetActiveLayer(string layer)
    {

        //search for the active layer based on the string and set it to the active layer.
        for (int i = 0; i < paperDollLayers.Length; i++)
        {

            if (paperDollLayers[i].name == layer)
            {

                activeLayer = i;
                break;
            }

        }

        Debug.Log("ActiveLayer = " + activeLayer);

        //resets button and layers so that they previous ones are not editted by accident.
        ResetButtonSelection();
        ResetLastSelectedLayer();

        layer = layer.ToUpper();

        switch (layer)
        {

            case "BODY": //layer template

                FillButtons(ConstructKey("bodytypekey")); //assigns sprites to the grid, activating the appropriate number of buttons on buttonGrid to list all the sprites in the folder.
                SetButtonPressedStates(bodyType); //leaves the button with the sprite of the current body type pressed, with the rest remaining in normal state (unpressed).
                picker.CurrentColor = paperDollLayers[activeLayer].color; //sets the color of the body to be the one selected on the color pick for easier editing.
                lastSelectedLayer = skinLayer; //since the body color should coordinate with other layers associated with skin, the skinlayer is used.  This will also update things like head, chest.
                
                ChangeFixedColumnCount(3);//number of columns is 3 on the grid.
                ResizeButtonGridSprites(1); //sprites will be at normal transform.scale = (1, 1, 1)


                break;
            case "CLOTHING":  //sublayer parent template

                FillButtons(ConstructKey("clothingtypekey"));
                SetButtonPressedStates(ReturnIndexsForFilledLayers(paperDollClothingLayers)); //uses overloaded method to 
                ResetActiveColor(); //since the player hasn't selected a sprite to edit, the current color on the color picker will remain white until a sprite is selected.
                SetLayerColorstoButtonGrid(paperDollClothingLayers); //takes the sublayers' colors and applies them in order on the buttonGrid for easier editing.  
                
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "CHEST": //layer

                FillButtons(ConstructKey("chesttypekey"));
                SetButtonPressedStates(chestType);
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = skinLayer;
               
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;
      

            case "ACCESSORIES":

                break;

            case "HANDS": //sublayer parent

                FillButtons(ConstructKey("HandTypeKey"));
                SetButtonPressedStates(ReturnIndexsForFilledLayers(paperDollHandLayers));
                ResetActiveColor();
                SetLayerColorstoButtonGrid(paperDollHandLayers);
                
                ChangeFixedColumnCount(2);
                ResizeButtonGridSprites(3);
                break;

            case "BACK":
                
                FillButtons(ConstructKey("BackTypeKey"));
                SetButtonPressedStates(backSprite);
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "CAPE":
                FillButtons(ConstructKey("CapeTypeKey"));
                SetButtonPressedStates(capeSprite);
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);

                break;

            case "SHOULDER":
                FillButtons(ConstructKey("ShoulderTypeKey"));
                SetButtonPressedStates(shoulderSprite);
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "EQUIPMENT": //sublayer parent

                FillButtons(ConstructKey("EquipmentTypeKey"));
                SetButtonPressedStates(ReturnIndexsForFilledLayers(paperDollEquipmentLayers));
                ResetActiveColor();
                SetLayerColorstoButtonGrid(paperDollEquipmentLayers);

                ChangeFixedColumnCount(2);
                ResizeButtonGridSprites(1);
                break;
                
            case "HEAD":
                break;

            case "HAIR":
                FillButtons(ConstructKey("HairTypeKey"));
                SetButtonPressedStates(hairSprite);
              
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "RACIALFEATURE":
                FillButtons(ConstructKey("RacialFeatureKey"));
                SetButtonPressedStates(racialSprite);
                
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = skinLayer;
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "HELMET":
                FillButtons(ConstructKey("HelmetTypeKey"));
                SetButtonPressedStates(helmetSprite);
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            default:
                break;

        }

    }

    //takes a paperdoll layer or sub layer and returns values that represent the layers that are enabled as gameobjects (this is mostly for clothing) 
    int[] ReturnIndexsForFilledLayers(Image[] layers) {

        List<int> activeLayers = new List<int>(); //holds the list of active layers 

        for(int i = 0; i < layers.Length; i++) {

            if (layers[i].sprite != blankSprite) //checks if the layer is active
            {

                activeLayers.Add(i);

                //Debug.Log(i);
            }

            else { }


        }

        int[] temp = activeLayers.ToArray();

        return temp;


    }

    int lastfilledAccessory = 0;

    Image ReturnEmptySubLayer(Image[] layers) {

        for (int i = 0; i < layers.Length; i++) {

            if (layers[i].sprite == blankSprite) {

                return layers[i];

            }
            
        }
        lastfilledAccessory++;
        return layers[lastfilledAccessory];

    }

    bool DoesLayerContainSubLayers(Image layer) {

        for (int i = 0; i < subLayers.Length; i++) {

            if (layer.name == subLayers[i]) {

                return true;

            }

        }

        return false;

    }

    //checks the image or layer and returns true if it is equal to the emptySprite (public variable)
    bool IsLayerEmpty(Image layer) {

        if (layer.sprite == blankSprite)
            return true;

        else
            return false;
            
    }

    //uses activeLayer to return the current paperdollLayer array.  switch case for sublayers that have the
    Image[] ReturnActiveLayers() {

        string layerName = paperDollLayers[activeLayer].name;

        switch (layerName) {

            case "Clothing":
                return paperDollClothingLayers;

            case "Hands":
                return paperDollHandLayers;

            default:
                return paperDollLayers;
                
        }
        
    }

    //called by UI elements to change the lastSelected layer to an emptyImage.  Primarily used to keep the color picker from editing a previous layer
    void ResetLastSelectedLayer() {

        lastSelectedLayer = emptyImage;
        
    }

   

    #endregion

    #region ColorPicker Methods

    //for use in start()
    void SetUpColorPicker() {

        picker.CurrentColor = Color.white;

        picker.onValueChanged.AddListener(color =>
        {
            activeRenderer.material.color = color;
        });

    }

    //for preset buttons in UI
    public void SetActiveColor(Button button)
    {

        Image buttonImage = button.GetComponent<Image>();

        picker.CurrentColor = buttonImage.color;

    }

    //sets the passed layer to become our last selected layer.  
    void LayerToBeColored(Image layer) {

        lastSelectedLayer = layer;
        
    }

    //called in update().  sets the color of the last selected layer using the color picker.
    public void UpdateActiveLayerColor()
    {
        
        lastSelectedLayer.color = activeRenderer.material.color;


    }
    
    //not really sure what this does again. probably used in the UI somewhere
    public void ResetActiveColor()
    {
        picker.SendChangedEvent();
    }

    #endregion

    #region Paperdoll Methods

    //Finds gameobjects based on tag and returns the image array.  for use in setting up Paperdoll layers and sublayers
    Image[] ReturnImagesFromTag(string layerTag)
    {

        List<Image> tempList = new List<Image>(); // new list to place our filtered images
        
        RectTransform[] layerObjects = paperDoll.transform.GetComponentsInChildren<RectTransform>(); //creates an array with all the objects that fit our tag.

        for (int i = 0; i < layerObjects.Length; i++)
        {
            if (layerObjects[i].tag == layerTag) {
                Image imgComponent = layerObjects[i].GetComponent<Image>();

                tempList.Add(imgComponent);
            }

            // Debug.Log(imgComponent.gameObject.name);

        }

        Image[] layers = tempList.ToArray();

        return layers;

    }

    //overloaded for use of an image and its gameobject.  pass in paperdollLayers[i] that are parents of sublayers (such as clothing) as the image variable to return their sublayers as an image[]
    Image[] ReturnImagesFromTag(string layerTag, Image parentImage)
    {

        List<Image> tempList = new List<Image>();
        //gets the root object and the children
        RectTransform[] layerObjects = parentImage.gameObject.GetComponentsInChildren<RectTransform>(true);

        for (int i = 0; i < layerObjects.Length; i++)
        {

            if (layerObjects[i].tag == layerTag) //sort the children by the given tag and put them into a new list. this should not allow the root object into the new list.
            {

                Image imgComponent = layerObjects[i].GetComponent<Image>();

                tempList.Add(imgComponent);

                //Debug.Log(imgComponent.gameObject.name);

            }

            else { }

        }

        Image[] layers = tempList.ToArray();

        return layers;
    }

    //used by a toggle UI to save the clothing preferences when switching between races.
    public void ToggleClothingPersistance() {

        isClothingPersistent = !isClothingPersistent;

    }

    //for use of UI race buttons to change race and the dependant variables
    /*public void ChangeRace(string race)
    {
        ApplyPaperdollToToken(currentToken);
        race = race.ToUpper();

        /*switch (race)
        {

            case "DWARF":
                raceID = 1;
                headString = "Base";
                raceType = 0;
                bodyType = 2;
                size = 0;
                break;

            case "HUMAN":
                raceID = 2;
                headString = "Base";
                raceType = 0;
                bodyType = 1;
                size = 0;
                break;

            case "HALFELF":
                raceID = 3;
                headString = "HalfEars";
                raceType = 0;
                bodyType = 1;
                size = 0;
                break;

            case "ELF":
                raceID = 4;
                headString = "LongEars";
                raceType = 0;
                bodyType = 1;
                size = 0;
                break;

            case "DRAGONBORN":
                raceID = 5;
                headString = "Dragonborn";
                raceType = 1;
                bodyType = 1;
                chestType = 0;
                hairSprite = 0;
                racialSprite = 1;
                size = 0;
                break;

            case "HALFORC":
                raceID = 6;
                headString = "HalfEars";
                raceType = 0;
                bodyType = 4;
                size = 0;
                break;

            case "HALFLING":
                raceID = 7;
                headString = "Base";
                raceType = 0;
                bodyType = 1;
                size = 1;
                break;

            case "GNOME":
                raceID = 8;
                headString = "LongEars";
                raceType = 0;
                bodyType = 0;
                size = 1;
                break;

            case "TIEFLING":
                raceID = 9;
                headString = "LongEars";
                raceType = 2;
                bodyType = 1;
                size = 0;
                break;
                
            default:
                break;



            case "DWARF":
                currentToken = dwarfToken;
                break;

            case "HUMAN":
                currentToken = humanToken;
                break;

            case "HALFELF":
                currentToken = halfelfToken;
                break;

            case "ELF":
                currentToken = elfToken;
                break;

            case "DRAGONBORN":
                currentToken = dragonbornToken;
                break;

            case "HALFORC":
                currentToken = halforcToken;
                break;

            case "HALFLING":
                currentToken = halflingToken;
                break;

            case "GNOME":
                currentToken = gnomeToken;
                break;

            case "TIEFLING":
                currentToken = tieflingToken;
                break;
                
            default:
                break;
        }

        ApplyTokenToPaperdoll(currentToken);
        UpdatePaperDoll();

    }*/

    public void ChangeRace(Token token) {


        ApplyPaperdollToToken(previousToken);

        if (isClothingPersistent)
        {
            size = token.size;
            chestType = token.chestType;
            raceID = token.raceID;
            raceType = token.raceType;
            bodyType = token.bodyType;
            headString = token.head;
            hairSprite = token.hairSprite;
            racialSprite = token.racialSprite;
            
        }

        else {
            
            ApplyTokenToPaperdoll(token);
           
        }

        previousToken = token;
        ApplyPaperdollToToken(currentToken);
        UpdatePaperDoll();

    }

    //used by the UI buttons on the button grid.  places the sprite represented on the grid onto the paperdoll at the active layer 
    public void SetSpriteToPaperdoll(Button button) {
        
        //get the button sprite
        Image buttonImage = button.transform.GetChild(0).GetComponent<Image>(); // gets the sprite from the child object's image that actually holds the sprite we want.
        Sprite buttonSprite = buttonImage.sprite;

        //determines if we are currently in a sublayer parent, then manages that button's selection state
        if (DoesLayerContainSubLayers(paperDollLayers[activeLayer])){
            
            SetButtonSeletionState(button);
            
        }
        

        //finds and holds index for this button on the grid
        int buttonIndex = 0;
        for (int i = 0; i < currentbuttonGridLength; i++) {

            if (buttonGrid[i] == button) {

                buttonIndex = i;

            }
            
        }
        
        //holds the image and name of the active layer
        //Sprite paperdollLayerSprite = paperDollLayers[activeLayer].sprite;
        string layerName = paperDollLayers[activeLayer].name.ToUpper(); //used in switch case so that we don't have to hard code in the numbers like we used to.  don't do that again.
        
        switch (layerName) {

            case "BODY": //layer

                paperDollLayers[activeLayer].sprite = buttonSprite; //sets the sprite of this button to the active layer
                TogglePressedStateAsGroup(button); //manages the toggled pressed states of all the buttons within buttonGrid as if they were a toggle group.
               
                bodyType = buttonIndex; //sets the body type based on the button's index.
                Debug.Log("BodyType = " + bodyType);

                break;
                
            case "CHEST": //layer
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                
                chestType = buttonIndex;
                Debug.Log("ChestType = " + chestType);

                break;

            case "HAIR": //layer
                paperDollLayers[activeLayer].sprite = buttonSprite;
                
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                hairSprite = buttonIndex;
                Debug.Log("HairSprite = " + hairSprite);
                break;

            case "CLOTHING": //sublayer parent
                lastSelectedLayer = paperDollClothingLayers[buttonIndex]; //this button's index will be used to set the sublayer as the last selected layer.  for normal layers this is called in "SetActiveLayer"
                picker.CurrentColor = buttonImage.color; //sets the current color of the picker to the button's color for ease of editting.
                if (WasButtonLastSelected(button) && IsButtonPressed(button)) //an early break statement.  This allows the player to press an already pressed button so it's color can be editted.  
                    break;
                paperDollClothingLayers[buttonIndex].sprite = ReturnButtonSpriteAsToggle(button); //sets the button sprite to the approprate sub layer, then toggles this button accordingly.
             
                break;

            case "CAPE":
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                capeSprite = buttonIndex;

                Debug.Log("CapeSprite = " + capeSprite);
                break;

            case "BACK":
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                backSprite = buttonIndex;

                Debug.Log("BackSprite = " + backSprite);
                break;

            case "SHOULDER":
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                shoulderSprite = buttonIndex;

                Debug.Log("ShoulderSprite = " + shoulderSprite);
                break;

            case "EQUIPMENT":

                lastSelectedLayer = paperDollEquipmentLayers[buttonIndex];
                picker.CurrentColor = buttonImage.color;
                if (WasButtonLastSelected(button) && IsButtonPressed(button))
                    break;
                paperDollEquipmentLayers[buttonIndex].sprite = ReturnButtonSpriteAsToggle(button);
                break;

            case "HANDS":
                
                lastSelectedLayer = paperDollHandLayers[buttonIndex];
                picker.CurrentColor = buttonImage.color;
                if (WasButtonLastSelected(button) && IsButtonPressed(button))
                    break;
                paperDollHandLayers[buttonIndex].sprite = ReturnButtonSpriteAsToggle(button);
                break;

            case "RACIALFEATURE":

                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                
                racialSprite = buttonIndex;
                Debug.Log("RacialFeatureSprite = " + racialSprite);
                break;

            case "HELMET":
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                helmetSprite = buttonIndex;

                Debug.Log("HelmetSprite = " + helmetSprite);
                break;

            default:
                break;
                


        }

        UpdatePaperDoll();
        
    }

    //used by UI button "Random".  assigns random values to sprites then uses UpdatePaperdoll to apply them.  Also uses set active layer to update button pressed states and colors.
    //does not randomize color yet.
    public void RandomizePaperdoll() {

        //body
        bodyType = Random.Range(0, bodyStrings.Length); //sets a random body type

        //hair 
        hairSprite = Random.Range(0, spriteLibrary.GetSprites(ConstructKey("hairtypekey")).Length);
        

        //clothing
        Sprite[] clothingSprites = spriteLibrary.GetSprites(ConstructKey("clothingtypekey"));
        

        for (int i = 0; i < paperDollClothingLayers.Length; i++) {

            if (Random.value < 0.5f)
                paperDollClothingLayers[i].sprite = clothingSprites[i];

            else
                paperDollClothingLayers[i].sprite = blankSprite;

        }

        //hands  this will stay commented out until we have more hand sprites.
        /*Sprite[] handSprites = spriteLibrary.GetSprites(ConstructKey("handtypekey"));

        int handCounter = 0;
        int maxHandSprites = 4;

        for (int i = 0; i < paperDollHandLayers.Length; i++)
        {

            if (Random.value < 0.5f)
            {
                paperDollHandLayers[i].sprite = handSprites[i];
                handCounter++;
            }
                
            else
                paperDollHandLayers[i].sprite = blankSprite;

            
            if (handCounter == maxHandSprites)
                break;
        }
        */




        //cape
        capeSprite = Random.Range(0, spriteLibrary.GetSprites("CAPEITEMS").Length);
        



        SetActiveLayer(paperDollLayers[activeLayer].name); //updates the buttons 


        UpdatePaperDoll(); //updates the paperdolls


    }

    //called in SetSpriteToPaperdoll() and other UI buttons.  updates sprites that are dependant on other variables, such as race, body type, chest type, etc.
    void UpdatePaperDoll() {
        
        //update body based on race
        paperDollLayers[0].sprite = spriteLibrary.GetSprite(ConstructKey("bodytypekey"), bodyType);
        
        //update chest
        paperDollLayers[1].sprite = spriteLibrary.GetSprite(ConstructKey("chesttypekey"), chestType);
        
        //update clothes
        for (int i = 0; i < paperDollClothingLayers.Length; i++) {

            if (!IsLayerEmpty(paperDollClothingLayers[i])) {
                paperDollClothingLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("clothingtypekey"), i);
                
            }
            
        }

        //update hands
        for (int i = 0; i < paperDollHandLayers.Length; i++)
        {

            if (!IsLayerEmpty(paperDollHandLayers[i]))
            {
               paperDollHandLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("handtypekey"), i);
                
            }

        }

        //capes
        paperDollLayers[4].sprite = spriteLibrary.GetSprite(ConstructKey("capetypekey"), capeSprite);

        //capes
        paperDollLayers[5].sprite = spriteLibrary.GetSprite(ConstructKey("backtypekey"), backSprite);

        //shoulders
        paperDollLayers[6].sprite = spriteLibrary.GetSprite(ConstructKey("shouldertypekey"), shoulderSprite);

        //update equipment
        for (int i = 0; i < paperDollEquipmentLayers.Length; i++)
        {

            if (!IsLayerEmpty(paperDollEquipmentLayers[i]))
            {
                paperDollEquipmentLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("equipmenttypekey"), i);

            }

        }

        //update head based on race
        paperDollLayers[8].sprite = spriteLibrary.GetSprite("HEADS", ConstructKey("headtypekey"));

        //update hair based on race
        paperDollLayers[9].sprite = spriteLibrary.GetSprite(ConstructKey("hairtypekey"), hairSprite);
        
        //update racial feature
        if (raceType == 0)
        {

            paperDollLayers[10].sprite = blankSprite;
            racialSprite = 0;

        }

        else {

            paperDollLayers[10].sprite = spriteLibrary.GetSprite(ConstructKey("racialfeaturekey"), racialSprite);

        }

        //update helmet based on race
        paperDollLayers[11].sprite = spriteLibrary.GetSprite(ConstructKey("helmettypekey"), helmetSprite);


    }

    //updates the color of all the layers dependant on skin color, such as body, chest, and head.  skinLayer is the first object in the skinLayers array.
    void UpdateSkinColor() {

        skinColor = skinLayer.color;

        for (int i = 0; i < skinLayers.Length; i++) {

            skinLayers[i].color = skinColor;
            
        }
        
    }

    //changes the scale of the paperdoll for closer inspection by the player.  called by UI elements
    public void ResizePaperdoll(int resize)
    {
        paperDoll.transform.localScale = new Vector3(resize, resize, resize);
    }
    
    //for use of Mirror button in UI.  flips the image across the y axis as a toggle
    public void MirrorLayer() {

        float currentRotation = lastSelectedLayer.rectTransform.localRotation.y;
        
        if (currentRotation == 0)
            lastSelectedLayer.rectTransform.localRotation = new Quaternion(0, 180, 0, 0);

        else
            lastSelectedLayer.rectTransform.localRotation = new Quaternion(0, 0, 0, 0);
        
    }

    #endregion
    
    #region Button Grid Methods

    //called in Start(). defines the buttonGrid
    void SetUpButtons()
    {

        buttonGrid = gridObject.transform.GetComponentsInChildren<Button>();

    }

    //activates the appropriate number of buttons needed, applying the appropriate sprite dictated by the sprite library
    void FillButtons(string filePath) {
        //gets the sprites from the library
        Sprite[] sprites = spriteLibrary.GetSprites(filePath);
        //activates the appropriate number of buttons on the grid.
        if (currentbuttonGridLength < sprites.Length) {

            for (int i = currentbuttonGridLength; i < sprites.Length; i++) {

                buttonGrid[i].gameObject.SetActive(true);

            }

        }
        //updates the image o the buttons to be those from the sprite library
        for (int i = 0; i < sprites.Length; i++)
        {

            //set sprite
            Image buttonImage = buttonGrid[i].transform.GetChild(0).GetComponent<Image>(); //requires get child, as the buttons in the grid hold a child object with the image component.  this component is the one we apply the sprites to.
            
            buttonImage.sprite = sprites[i];

        }
        //deactivates any un-needed buttons
        for (int i = sprites.Length; i < buttonGrid.Length; i++)
        {

            buttonGrid[i].gameObject.SetActive(false);

        }
        //updates the current length of the button grid.  
        currentbuttonGridLength = sprites.Length;
        
    }

    //resizes images on the button grid.  when increasing size the sprites would shift and the last part of this method helps normalize that.
    void ResizeButtonGridSprites(int resize) {

        for (int i = 0; i < currentbuttonGridLength; i++) {

            Image buttonImage = buttonGrid[i].transform.GetChild(0).GetComponent<Image>();
                
            buttonImage.transform.localScale = new Vector3(resize, resize, resize); //changes the scale of the image

            float repos = resize - 1; //for resize 1, this will create a reposition vector of o,o,o.  

            buttonImage.rectTransform.position = Vector3.zero;  

            //the following is for the hands layer, which requires that the even images be centered more to the right with the odd images to the left
            if (i % 2 == 0 || i == 0) {
                float x = repos * 30.0f;
                buttonImage.transform.localPosition = new Vector3(x, 0, 0);
            }
            
            else {
                float x = repos * -30.0f;
                buttonImage.transform.localPosition = new Vector3(x, 0, 0);
            }
               
                

        }

    }

    //changes the number of columns in the grid
    void ChangeFixedColumnCount(int size) {

        gridObject.GetComponent<GridLayoutGroup>().constraintCount = size;
        
    }

    //manages the button's selection state between inactive (not pressed), active (pressed), and selected (being edited by the color picker)
    void SetButtonSeletionState(Button button) {

        if (IsButtonPressed(button) && WasButtonLastSelected(button))
        {

            lastSelectedButton = emptyButton;

        }

        else if (IsButtonPressed(button) && !WasButtonLastSelected(button))
        {

            lastSelectedButton = button;

        }

        else if (!IsButtonPressed(button)) {

            lastSelectedButton = button;

        }

        Debug.Log("Last Selected Button was " + button.name);

    }
    
    //checks if the button passed through the method equals the lastSelectedButton, and if so returns true
    bool WasButtonLastSelected(Button button) {

        if (lastSelectedButton == button)
            return true;
        
        else
            return false;
        
    }
    
    //called in Update(), this updates the colors of the buttons.  
    void UpdateButtonColor() {
        
        bool isSubLayer = DoesLayerContainSubLayers(paperDollLayers[activeLayer]);

        //check see if the active layer contains sublayers

        Image[] layers = ReturnActiveLayers();
        
        if (isSubLayer) // if the active layer is a sublayer, then only update the last selected button.  this is used for clothing, hands, and other layers that contain sublayers
        {
            lastSelectedButton.transform.GetChild(0).GetComponent<Image>().color = lastSelectedLayer.color;
        }
           
        
        else{ //if the active layer is not a sublayer, then update all the buttons on the grid.  this is used for body, hair, capes, etc
            
            for (int i = 0; i < currentbuttonGridLength; i++)
            {

                buttonGrid[i].transform.GetChild(0).GetComponent<Image>().color = layers[activeLayer].color;

            }

        }
        
    }

    //places a button in a pressed state if the type of that item is currently active on the paperdoll.  then places the rest of the buttons into the unpressed state
    void SetButtonPressedStates(int type) {

        if (paperDollLayers[activeLayer].gameObject.activeSelf)
        {
            
            for (int i = 0; i < currentbuttonGridLength; i++)
            {

                if (i == type)
                {

                    buttonGrid[i].image.color = buttonGrid[i].colors.pressedColor;
                }

                else {

                    buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

                }

            }

        }

        else {


            for (int i = 0; i < currentbuttonGridLength; i++)
            {

               buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

            }

        }



    }

    //overload method that takes an array rather than a single interger.
    void SetButtonPressedStates(int[] types)
    {
        //sets all buttons into an unpressed state
        for (int i = 0; i < currentbuttonGridLength; i++)
        {

            buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

        }
        //then presses the ones that are currently active on the paperdoll
        for (int i = 0; i < types.Length; i++) {

            buttonGrid[types[i]].image.color = buttonGrid[types[i]].colors.pressedColor;
            
        }

    }

    //checks if the button is in the pressed state, returning true if it is.
    bool IsButtonPressed(Button button) {

        if (button.image.color == button.colors.pressedColor)
            return true;
        
        else
            return false;
            
    }

    //this will return the sprite associated with the button passed through this method.  It will also toggle it's pressed state.
    Sprite ReturnButtonSpriteAsToggle(Button button)
    {

        Sprite buttonSprite = button.transform.GetChild(0).GetComponent<Image>().sprite; // gets the sprite from the child object's image that actually holds the sprite we want.

        //checks to see if the button is not yet pressed.  if the button is normal color (not pressed) apply the button's sprite and change it to pressed color;
        if (!IsButtonPressed(button))
        {

            button.image.color = button.colors.pressedColor;
            return buttonSprite;

        }
        //if button was already pressed and active, toggle it back to the normal color and return a blank sprite.
        else
        {

            button.image.color = button.colors.normalColor;
            return blankSprite;

        }

    }

    //toggles between pressed and normal states.
    void TogglePressedState(Button button)
    {

        //checks to see if the button is not yet pressed.  if the button is normal color (not pressed) apply the button's sprite and change it to pressed color;
        if (!IsButtonPressed(button))
            button.image.color = button.colors.pressedColor;
            
        //if button was already pressed and active, toggle it back to the normal color and return a blank sprite.
        else
            button.image.color = button.colors.normalColor;
            
    }

    //toggles a set of buttons as a group, ensuring only one button is pressed from the group at a time. similar to a toggle group component
    void TogglePressedStateAsGroup(Button button)
    {
        
        for (int i = 0; i < buttonGrid.Length; i++){

            if (buttonGrid[i] == button) { //looks for the button within the grid, making sure it is in the pressed state
                
                buttonGrid[i].image.color = buttonGrid[i].colors.pressedColor;
                
            }

            else
            {// sets the rest of the buttons in the grid that are not the target button to normal color (unpressed)

                buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;
                
            }


        }

    }

    //sets last selectedbutton to emptyButton
    void ResetButtonSelection() {

        lastSelectedButton = emptyButton;

    }
    
    //Used by catagory buttons in UI to apply colors from the layer to the appropriate buttons.
    void SetLayerColorstoButtonGrid(Image layer)
    {

        for (int i = 0; i < buttonGrid.Length; i++)
        {

            buttonGrid[i].transform.GetChild(0).GetComponent<Image>().color = layer.color;

        }

    }

    //overloaded for SubLayers
    void SetLayerColorstoButtonGrid(Image[] layers) {

        for (int i = 0; i < layers.Length; i++) {

            buttonGrid[i].transform.GetChild(0).GetComponent<Image>().color = layers[i].color;
            
        }

    }
   
    //sets all the buttons in the button grid to white
    void ResetColorsOnButtonGrid() {


        for (int i = 0; i < buttonGrid.Length; i++)
        {

            Image buttonImage = buttonGrid[i].transform.GetChild(0).GetComponent<Image>();
            buttonImage.color = Color.white;

        }

    }

    //sets all buttons on the buttonGrid to be inactive
    public void DeactivateAllButtons() {

        for (int i = 0; i < buttonGrid.Length; i++){

            buttonGrid[i].gameObject.SetActive(false);

        }

        currentbuttonGridLength = 0;

    }

    #endregion

    #region Token Methods

    public void ApplyTokenToPaperdoll(Token token) {

        if (token == null) {return;}

        exportName = token.tokenName;

        size = token.size;
        chestType = token.chestType;
        raceID = token.raceID;
        raceType = token.raceType;
        bodyType = token.bodyType;
        headString = token.head;

        hairSprite = token.hairSprite;
        capeSprite = token.capeSprite;
        backSprite = token.backSprite;
        shoulderSprite = token.shoulderSprite;
        helmetSprite = token.helmetSprite;
        racialSprite = token.racialSprite;

        for (int i = 0; i < token.clothingSprites.Length; i++) {

            if (token.clothingSprites[i])
                paperDollClothingLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("clothingtypekey"), i);

            else
                paperDollClothingLayers[i].sprite = blankSprite;

        }
        
        for (int i = 0; i < token.handSprites.Length; i++)
        {

            if (token.handSprites[i])
                paperDollHandLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("handtypekey"), i);

            else
                paperDollHandLayers[i].sprite = blankSprite;

        }

        for (int i = 0; i < token.equipmentSprites.Length; i++)
        {

            if (token.equipmentSprites[i])
                paperDollEquipmentLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("equipmenttypekey"), i);

            else
                paperDollEquipmentLayers[i].sprite = blankSprite;

        }

        for (int i = 0; i < paperDollLayers.Length; i++)
        {
            paperDollLayers[i].color = token.paperdollLayerColors[i];
            paperDollLayers[i].rectTransform.localRotation = new Quaternion(0, token.paperdollLayerRotations[i], 0, 0);
        }
        

        for (int i = 0; i < paperDollClothingLayers.Length; i++)
        {
            paperDollClothingLayers[i].color = token.paperdollClothingLayerColors[i];
            paperDollClothingLayers[i].rectTransform.localRotation = new Quaternion(0, token.paperdollClothingLayerRotations[i], 0, 0);
        }


        for (int i = 0; i < paperDollHandLayers.Length; i++)
        {
            paperDollHandLayers[i].color = token.paperdollHandLayerColors[i];
            paperDollHandLayers[i].rectTransform.localRotation = new Quaternion(0, token.paperdollHandLayerRotations[i], 0, 0);
        }

        for (int i = 0; i < paperDollEquipmentLayers.Length; i++)
        {
            paperDollEquipmentLayers[i].color = token.paperdollEquipmentLayerColors[i];
            paperDollEquipmentLayers[i].rectTransform.localRotation = new Quaternion(0, token.paperdollEquipmentLayerRotations[i], 0, 0);
        }


        ResetLastSelectedLayer();

        UpdatePaperDoll();
        
    }

    public void ApplyPaperdollToToken(Token token) {

        if (token == null) { return; }
        
        token.tokenName = exportName;

        token.size = size;
        token.chestType = chestType;
        token.raceID = raceID;
        token.bodyType = bodyType;
        token.raceType = raceType;
        token.head = headString;

        token.hairSprite = hairSprite;
        token.capeSprite = capeSprite;
        token.backSprite = backSprite;
        token.shoulderSprite = shoulderSprite;
        token.helmetSprite = helmetSprite;
        token.racialSprite = racialSprite;

        for (int i = 0; i < token.clothingSprites.Length; i++)
        {

            if (!IsLayerEmpty(paperDollClothingLayers[i]))
                token.clothingSprites[i] = true;

            else
                token.clothingSprites[i] = false;

        }

        for (int i = 0; i < token.handSprites.Length; i++)
        {


            if (!IsLayerEmpty(paperDollHandLayers[i]))
                token.handSprites[i] = true;

            else
                token.handSprites[i] = false;

        }

        for (int i = 0; i < token.equipmentSprites.Length; i++)
        {


            if (!IsLayerEmpty(paperDollEquipmentLayers[i]))
                token.equipmentSprites[i] = true;

            else
                token.equipmentSprites[i] = false;

        }

        for (int i = 0; i < paperDollLayers.Length; i++)
        {

            token.paperdollLayerColors[i] = paperDollLayers[i].color ;
            token.paperdollLayerRotations[i] = paperDollLayers[i].rectTransform.localRotation.y;

        }

        for (int i = 0; i < paperDollClothingLayers.Length; i++)
        {

            token.paperdollClothingLayerColors[i] = paperDollClothingLayers[i].color;
            token.paperdollClothingLayerRotations[i] = paperDollClothingLayers[i].rectTransform.localRotation.y;
        }

        for (int i = 0; i < paperDollHandLayers.Length; i++)
        {

            token.paperdollHandLayerColors[i] = paperDollHandLayers[i].color;
            token.paperdollHandLayerRotations[i] = paperDollHandLayers[i].rectTransform.localRotation.y;
        }

        for (int i = 0; i < paperDollEquipmentLayers.Length; i++)
        {

            token.paperdollEquipmentLayerColors[i] = paperDollEquipmentLayers[i].color;
            token.paperdollEquipmentLayerRotations[i] = paperDollEquipmentLayers[i].rectTransform.localRotation.y;
        }
        

    }

    #endregion  

    #region PNG Export Methods

    //for stupid button use
    public void StartUploadPNG() {

      StartCoroutine("UploadPNG");
      
    }

    //Sets the name of the file
    public void SetExportName(string name) {

        exportName = name;
        currentToken.tokenName = name;
        //Debug.Log(exportName);
        
    }

    //enumerated method for saving the PNG file to screenshots
    IEnumerator UploadPNG()
    {
        //from unity documentation

        RectTransform paperDollRectTransform = paperDoll.GetComponent<RectTransform>();

        //stores old settings and changes them for the screenshot
        Vector3 paperDollOldPos = paperDollRectTransform.position;
        Vector3 paperDollOldScale = paperDollRectTransform.localScale;

        paperDollRectTransform.position = new Vector3(40, 40, 0);
        paperDollRectTransform.localScale = new Vector3(1, 1, 1);

        //get rid of background temporarily to preserve alpha
        canvasBackgroundObject.SetActive(false);
        gridObject.SetActive(false);

        // We should only read the screen buffer after rendering is complete
        yield return new WaitForEndOfFrame();

        // Create a texture the size of the screen, ARGB32 format
       // int width = Screen.width;
       // int height = Screen.height;

      
        Texture2D tex = new Texture2D(70, 70, TextureFormat.ARGB32, false);
        
        // Read screen contents into the texture
        tex.ReadPixels(new Rect(5, 5, 75, 75), 0, 0);
        tex.Apply();

        // Encode texture into PNG
        byte[] bytes = tex.EncodeToPNG();
        Object.Destroy(tex);

        ReassignRedundantExportName(exportName, Application.streamingAssetsPath + "/Screenshots/");

        // For testing purposes, also write to a file in the project folder
        File.WriteAllBytes(Application.streamingAssetsPath + "/Screenshots/" + exportName + ".png", bytes);

        paperDollRectTransform.position = paperDollOldPos;
        paperDollRectTransform.localScale = paperDollOldScale;

        canvasBackgroundObject.SetActive(true);
        gridObject.SetActive(true);
        
        Debug.Log("Screenshot Taken");

        yield return 0;

    }

    //addes numbers to the export name to avoid redundant filenames
    void ReassignRedundantExportName(string name, string folderPath) {

        string[] filePaths = Directory.GetFiles(folderPath);

        int counter = 0;

        string currentFilePath;
        string lessRedundantName = name;

        bool isThereStillARedundancy;

        do
        {

            currentFilePath = Application.streamingAssetsPath + "/Screenshots/" + lessRedundantName + ".png";
            isThereStillARedundancy = false;

            foreach (string filePath in filePaths)
            {

                if (filePath == currentFilePath)
                {

                    counter++;
                    lessRedundantName = name + counter;
                    isThereStillARedundancy = true;
                    //Debug.Log(counter);
                    

                }

            }



        } while (isThereStillARedundancy);

        exportName = lessRedundantName;
      
    }
        
    #endregion
  
    // Use this for initialization
    void Start () {
        
        SetUpButtons();

        SetUpColorPicker();

        ResetButtonSelection();

        ResetLastSelectedLayer();

        //sets our paperdoll layer arrays
        paperDollLayers = ReturnImagesFromTag("PaperdollLayer");
        paperDollClothingLayers = ReturnImagesFromTag("PaperdollSubLayer", paperDollLayers[2]);
        paperDollHandLayers = ReturnImagesFromTag("PaperdollSubLayer", paperDollLayers[3]);
        paperDollEquipmentLayers = ReturnImagesFromTag("PaperdollSubLayer", paperDollLayers[7]);

        skinLayer = skinLayers[0]; //skinLayer only needs to be set to any of the skin layers

        previousToken = currentToken;

        ApplyTokenToPaperdoll(currentToken);
        
        DeactivateAllButtons();



       
      
}
	
	// Update is called once per frame
	void Update () {

        UpdateButtonColor();
        UpdateActiveLayerColor();
        UpdateSkinColor();
        //UpdatePaperDoll(); <- this is no longer called in update, but instead called as needed by SetSpriteToPaperDoll and other UI buttons


    }
}
