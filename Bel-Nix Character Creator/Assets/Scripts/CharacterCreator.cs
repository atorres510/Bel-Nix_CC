using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;


public class CharacterCreator : MonoBehaviour {


    [Header("Tokens")]
    public Token currentToken;
    public Token defaultToken;

    [Space(10)]

    public TokenBank tokenBank;
    public TokenBank defaultTokenBank;

    //in order of races;
    /*public Token dwarfToken;
    public Token humanToken;
    public Token halfelfToken;
    public Token elfToken;
    public Token dragonbornToken;
    public Token halforcToken;
    public Token halflingToken;
    public Token gnomeToken;
    public Token tieflingToken;*/

    [Space(20)]

    [Header("Components")]
    public SpriteLibrary spriteLibrary;
    public DataManger datamanger;
    public Renderer activeRenderer;
    public GameObject gridObject;
    public GameObject presetsObject;


    [Space(20)]

    [Header("UI Elements")]
    public ColorPicker picker;
    public UI_Selector selector;
    public GameObject canvasBackgroundObject;
    string exportName;
    public InputField UIcharacterNameField;
    public Button chestButton;
    public Button hornButton;
    public Button tailButton;

    [Space(10)]

    [Header("Empty UI Elements")]

    public Sprite blankUISprite;
    public Sprite blankSprite;
    public Image emptyImage;
    public Button emptyButton;

    Image skinLayer;
    Color skinColor;

    //Button grid variables
    Button[] buttonGrid;
    int currentbuttonGridLength = 0;


    [Space(20)]

    [Header("Paperdoll")]

    public GameObject paperDoll;

    Image lastSelectedLayer;
    Color layerColor;
    Button lastSelectedButton;

    Image paperDollBodyLayer;
    Image paperDollChestLayer;
    Image[] paperDollLayers;
    Image[] paperDollClothingLayers;
    Image[] paperDollHandLayers;
    Image[] paperDollEquipmentLayers;

    string[] subLayers = { "Clothing", "Hands", "Equipment" };
    public Image[] skinLayers;

    public int activeLayer; //layer based on the paperdoll order

    // informs the current race of the token.  this value is changed by the buttons in the RaceButtonList UI
    //determines presets, size, and raceType.  

    //int raceID = 2; default human
    // 1: Dwarf, 2: Human, 3: Half-elf
    // 4: Elf, 5: Dragonborn, 6: Half-Orc
    // 7: Halfling, 8: Gnome, 9: tiefling
    //add more races here!!

    //int chestType = 0; // 0"NoCup", 1"ACup", 2"BCup", 3"CCup", 4"DCup"
    //int size = 0; //0 medium, 1 small
    //int raceType = 0;   //0 Base, 1 Dragonborn, 2 tiefling
    //int bodyType = 1; //0"Bony", 1"BonyThin", 2"Fit", 3"FitThin", 4"Buff", 5"Stout", 6"Thick"

    //the rest of these ints simply correspond to the sprite in order of where they are in the grid (or sprite[] generated by the library)
    //int hairSprite = 1;
    //int capeSprite = 0; 
    //int backSprite = 0;
    //int shoulderSprite = 0;
    //int helmetSprite = 0;
    //int hornSprite = 0;
    //int tailSprite = 0;


    //arrays of strings that are used to construct the keys needed to GetSprites or FillButtons.  Used by ConstructKey
    //these will need to be in alphabetical order because that is how the folders are ordered.
    string headString = "Base";
    string[] sexStrings = { "F", "M" };
    string[] sizeStrings = { "Med", "Sm" };
    string[] chestStrings = { "NoCup", "ACup", "BCup", "CCup", "DCup" };
    string[] bodyStrings = { "Bony", "BonyThin", "Fit", "FitThin", "Buff", "Stout", "Thick" };
    string[] raceStrings = { "Base", "Dragonborn", "Tiefling" };

    //Stores Keys 
    string bodyTypeKey;
    string clothingTypeKey;
    string accessoryTypeKey;
    string hairTypeKey;

    #region Sprite Key Methods

    //takes all of the featureString variables and uses them to construct a specific key and returns it as a string for use by GetSprite or FillButton
    string ConstructKey(string keyType) {

        string key = "";

        keyType = keyType.ToUpper();

        //Debug.Log(keyType);

        switch (keyType) {

            case "BODY":

                key = "BodyType_" + sizeStrings[currentToken.size] + "_" + raceStrings[currentToken.raceType];

                break;

            case "CHEST":

                key = "ChestType_" + sizeStrings[currentToken.size] + "_" + GetSpriteNameID(paperDollBodyLayer); /*GetSpriteName(paperDollLayers[1])*/
                //key = "ChestType_" + sizeStrings[currentToken.size] + "_" + currentToken.bodyType /*GetSpriteName(paperDollLayers[1])*/;

                break;

            case "CLOTHING":

                key = "ClothingType_" + sizeStrings[currentToken.size] + "_" + GetSpriteNameID(paperDollBodyLayer)/*GetSpriteName(paperDollLayers[1])*/ + "_" + GetSpriteNameID(paperDollChestLayer);
                //key = "ClothingType_" + sizeStrings[currentToken.size] + "_" + currentToken.bodyType/*GetSpriteName(paperDollLayers[1])*/ + "_" + chestStrings[currentToken.chestType];
                //Debug.Log("Clothing key " + key);
                break;

            case "BACK":

                key = "BackType_" + sizeStrings[currentToken.size];

                break;

            case "HEAD":

                key = "HeadType_" + sizeStrings[currentToken.size];

                break;

            case "HAIR":

                key = "HairType_" + sizeStrings[currentToken.size] + "_" + raceStrings[currentToken.raceType];

                break;

            case "HANDS":

                key = "HandType_" + sizeStrings[currentToken.size] + "_" + raceStrings[currentToken.raceType] + "_" + GetSpriteNameID(paperDollBodyLayer) /*GetSpriteName(paperDollLayers[1])*/;

                break;

            case "CAPE":

                key = "CapeType_" + sizeStrings[currentToken.size];

                break;

            case "SHOULDER":

                key = "ShoulderType_" + sizeStrings[currentToken.size];

                break;

            case "HELMET":

                key = "HelmetType_" + sizeStrings[currentToken.size] + "_" + raceStrings[currentToken.raceType];

                break;

            case "EQUIPMENT":

                key = "EquipmentType_" + sizeStrings[currentToken.size];

                break;

            case "HORNS":

                key = "HornType_" + raceStrings[currentToken.raceType];

                break;

            case "TAIL":

                key = "TailType_" + raceStrings[currentToken.raceType];

                break;
                
            /*case "RACIALFEATUREKEY":

                 key = "racialFeatures_" + raceStrings[raceType];

                 break;*/

            default:
                Debug.Log(keyType);
                Debug.LogError("Defaulting in ConstructKey()");
                break;

        }

        key = key.ToUpper();

        //Debug.Log(key);

        return key;

    }

    string GetSpriteNameID(Image i) {

        Sprite s = i.sprite;

        string name = s.name;

        string[] splitName = name.Split('_');

        name = splitName[splitName.Length - 1];

        return name;
    }

    string GetSpriteNameID(Sprite s) {

        string name = s.name;

        string[] splitName = name.Split('_');

        name = splitName[splitName.Length - 1];

        return name;

    }

    string GetSpriteNameID(GameObject g) {

        Sprite s = g.GetComponent<Image>().sprite;

        string name = s.name;

        string[] splitName = name.Split('_');

        name = splitName[splitName.Length - 1];

        return name;
    }

    #endregion

    #region Layer and SubLayer Methods
    //the layer and sublayer methods are for UI use to set active layers and to fill the grid buttons with the appropriate sprites for use.  

    //For use of the UI to determine what layer of the paperdoll is currently being edited, and to fill the buttons with the appropriate sprites for player's selection
    public void SetActiveLayer(string layer)
    {

        //search for the active layer based on the string and set it to the active layer.
        for (int i = 0; i < paperDollLayers.Length; i++)
        {

            if (paperDollLayers[i].name == layer)
            {

                activeLayer = i;
                break;
            }

        }

        Debug.Log("ActiveLayer = " + activeLayer);

        //resets button and layers so that they previous ones are not editted by accident.
        ResetButtonSelection();
        ResetLastSelectedLayer();
        selector.ResetSelector();



        layer = layer.ToUpper();

        switch (layer)
        {
            case "TAIL":
                FillButtons(ConstructKey("Tail"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));

                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[tailSprite].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "BODY": //layer template

                FillButtons(ConstructKey("body")); //assigns sprites to the grid, activating the appropriate number of buttons on buttonGrid to list all the sprites in the folder.
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer])); //leaves the button with the sprite of the current body type pressed, with the rest remaining in normal state (unpressed).
                picker.CurrentColor = paperDollLayers[activeLayer].color; //sets the color of the body to be the one selected on the color pick for easier editing.
                lastSelectedLayer = paperDollLayers[activeLayer]; //since the body color should coordinate with other layers associated with skin, the skinlayer is used.  This will also update things like head, chest.
                //selector.SelectThis(buttonGrid[bodyType].GetComponent<RectTransform>());
                Debug.Log("Button: " + currentToken.bodyType);
                ChangeFixedColumnCount(3);//number of columns is 3 on the grid.
                ResizeButtonGridSprites(1); //sprites will be at normal transform.scale = (1, 1, 1)


                break;
            case "CLOTHING":  //sublayer parent template

                FillButtons(ConstructKey("clothing"));
                SetButtonsPressedStates(ReturnIndexsForFilledLayers(paperDollClothingLayers)); //uses overloaded method to 
                ResetActiveColor(); //since the player hasn't selected a sprite to edit, the current color on the color picker will remain white until a sprite is selected.
                SetLayerColorstoButtonGrid(paperDollClothingLayers); //takes the sublayers' colors and applies them in order on the buttonGrid for easier editing.  

                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "CHEST": //layer

                FillButtons(ConstructKey("chest"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[chestType].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "ACCESSORIES":

                break;

            case "HANDS": //sublayer parent

                FillButtons(ConstructKey("Hands"));
                SetButtonsPressedStates(ReturnIndexsForFilledLayers(paperDollHandLayers));
                ResetActiveColor();
                SetLayerColorstoButtonGrid(paperDollHandLayers);

                ChangeFixedColumnCount(2);
                ResizeButtonGridSprites(3);
                break;

            case "BACK":

                FillButtons(ConstructKey("Back"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[backSprite].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "CAPE":
                FillButtons(ConstructKey("Cape"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[capeSprite].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);

                break;

            case "SHOULDER":
                FillButtons(ConstructKey("Shoulder"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[shoulderSprite].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "EQUIPMENT": //sublayer parent

                FillButtons(ConstructKey("Equipment"));
                SetButtonsPressedStates(ReturnIndexsForFilledLayers(paperDollEquipmentLayers));
                ResetActiveColor();
                SetLayerColorstoButtonGrid(paperDollEquipmentLayers);

                ChangeFixedColumnCount(2);
                ResizeButtonGridSprites(1);
                break;

            case "HEAD":
                break;

            case "HAIR":
                FillButtons(ConstructKey("Hair"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));

                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[hairSprite].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "HORNS":
                FillButtons(ConstructKey("Horns"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));

                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[hornSprite].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            case "HELMET":
                FillButtons(ConstructKey("Helmet"));
                SetButtonPressedState(GetSpriteNameID(paperDollLayers[activeLayer]));
                picker.CurrentColor = paperDollLayers[activeLayer].color;
                lastSelectedLayer = paperDollLayers[activeLayer];
                //selector.SelectThis(buttonGrid[helmetSprite].GetComponent<RectTransform>());
                ChangeFixedColumnCount(3);
                ResizeButtonGridSprites(1);
                break;

            default:
                break;

        }

    }

    //takes a paperdoll layer or sub layer and returns values that represent the layers that are enabled as gameobjects (this is mostly for clothing) 
    int[] ReturnIndexsForFilledLayers(Image[] layers) {

        List<int> activeLayers = new List<int>(); //holds the list of active layers 

        for (int i = 0; i < layers.Length; i++) {

            if (layers[i].sprite != blankSprite) //checks if the layer is active
            {

                activeLayers.Add(i);

                //Debug.Log(i);
            }

            else { }


        }

        int[] temp = activeLayers.ToArray();

        return temp;


    }

    int[] ReturnIndexsForFilledLayers(Image[] paperDollLayers, List<string> tokenLayers)
    {

        List<int> activeLayers = new List<int>(); //holds the list of active layers 

        for (int i = 0; i < paperDollLayers.Length; i++)
        {

            if (tokenLayers.Contains(paperDollLayers[i].gameObject.name))
                activeLayers.Add(i);

        }

        int[] indexs = activeLayers.ToArray();

        return indexs;

    }

    int[] ReturnIndexsForFilledLayers(List<string> tokenLayers)
    {

        List<int> activeLayers = new List<int>(); //holds the list of active layers 

        string buttonSpriteNameID;

        for (int i = 0; i < buttonGrid.Length; i++)
        {

            buttonSpriteNameID = ReturnButtonSpriteNameID(buttonGrid[i]);

            if (tokenLayers.Contains(buttonSpriteNameID))
                activeLayers.Add(i);

        }

        int[] indexs = activeLayers.ToArray();

        return indexs;

    }

    bool DoesLayerContainSubLayers(Image layer) {

        for (int i = 0; i < subLayers.Length; i++) {

            if (layer.name == subLayers[i]) {

                return true;

            }

        }

        return false;

    }

    //checks the image or layer and returns true if it is equal to the emptySprite (public variable)
    bool IsLayerEmpty(Image layer) {

        if (layer.sprite == blankSprite)
            return true;

        else
            return false;

    }

    //uses activeLayer to return the current paperdollLayer array.  switch case for sublayers that have the
    Image[] ReturnActiveLayers() {

        string layerName = paperDollLayers[activeLayer].name;

        switch (layerName) {

            case "Clothing":
                return paperDollClothingLayers;

            case "Hands":
                return paperDollHandLayers;

            case "Equipment":
                return paperDollEquipmentLayers;

            default:
                return paperDollLayers;

        }

    }

    //called by UI elements to change the lastSelected layer to an emptyImage.  Primarily used to keep the color picker from editing a previous layer
    void ResetLastSelectedLayer() {

        lastSelectedLayer = emptyImage;

    }

    #endregion

    #region ColorPicker Methods

    //for use in start()
    void SetUpColorPicker() {

        picker.CurrentColor = Color.white;

        picker.onValueChanged.AddListener(color =>
        {
            activeRenderer.material.color = color;
        });

    }

    //for preset buttons in UI
    public void SetActiveColor(Button button)
    {

        Image buttonImage = button.GetComponent<Image>();

        picker.CurrentColor = buttonImage.color;

    }

    //sets the passed layer to become our last selected layer.  
    void LayerToBeColored(Image layer) {

        lastSelectedLayer = layer;

    }

    //called in update().  sets the color of the last selected layer using the color picker.
    public void UpdateActiveLayerColor()
    {

        lastSelectedLayer.color = activeRenderer.material.color;


    }

    //not really sure what this does again. probably used in the UI somewhere
    public void ResetActiveColor()
    {
        picker.SendChangedEvent();
    }

    #endregion

    #region Paperdoll Methods

    //Finds gameobjects based on tag and returns the image array.  for use in setting up Paperdoll layers and sublayers
    Image[] ReturnImagesFromTag(string layerTag)
    {

        List<Image> tempList = new List<Image>(); // new list to place our filtered images

        RectTransform[] layerObjects = paperDoll.transform.GetComponentsInChildren<RectTransform>(); //creates an array with all the objects that fit our tag.

        for (int i = 0; i < layerObjects.Length; i++)
        {
            if (layerObjects[i].tag == layerTag) {
                Image imgComponent = layerObjects[i].GetComponent<Image>();

                tempList.Add(imgComponent);
            }

            // Debug.Log(imgComponent.gameObject.name);

        }

        Image[] layers = tempList.ToArray();

        return layers;

    }

    //overloaded for use of an image and its gameobject.  pass in paperdollLayers[i] that are parents of sublayers (such as clothing) as the image variable to return their sublayers as an image[]
    Image[] ReturnImagesFromTag(string layerTag, Image parentImage)
    {

        List<Image> tempList = new List<Image>();
        //gets the root object and the children
        RectTransform[] layerObjects = parentImage.gameObject.GetComponentsInChildren<RectTransform>(true);

        for (int i = 0; i < layerObjects.Length; i++)
        {

            if (layerObjects[i].tag == layerTag) //sort the children by the given tag and put them into a new list. this should not allow the root object into the new list.
            {

                Image imgComponent = layerObjects[i].GetComponent<Image>();

                tempList.Add(imgComponent);

                //Debug.Log(imgComponent.gameObject.name);

            }

            else { }

        }

        Image[] layers = tempList.ToArray();

        return layers;
    }
    
    //for use of UI race buttons to change race and the dependant variables
    public void ChangeRace(int race) {
        
        ApplyPaperdollToToken(currentToken);

        //Find the newRacialToken and set currentToken to newRace settings
        
        Token newRacialToken = tokenBank.SearchTokenbyRace(race);
        
        /*if (currentToken.raceType == newRacialToken.raceType && currentToken.size == newRacialToken.size) {
            
            newRacialToken.independentLayers.Clear();
            newRacialToken.independentLayers.AddRange(currentToken.independentLayers);
            newRacialToken.subLayers.Clear();
            newRacialToken.subLayers.AddRange(currentToken.subLayers);
            
        }*/

        currentToken = newRacialToken;
        
        SetDefaultToken(race);
        //ApplyRacialExceptions(currentToken);
        ApplyTokenToPaperdoll(currentToken);
        RefreshPaperdoll();




        //Debug.Log("CC race type" + currentToken.raceType);
        //Debug.Log("CC raceID" + race);

    }

    //hardcoding exceptions to fix errors when changing races.  
    void ApplyRacialExceptions(Token token) {

        switch (token.size) {

            case 0: //med
                break;

            case 1: //sm
                if (GetSpriteNameID(paperDollBodyLayer) != "Bony" || GetSpriteNameID(paperDollBodyLayer) != "BonyThin")
                {

                    paperDollBodyLayer.sprite = spriteLibrary.GetSprite(ConstructKey("Body"), 0);

                }
                else { }
                break;

            default:
                break;

        }


        switch (token.raceType) {


            case 0: //base
                break;
            case 1: //dragonborn
                paperDollHandLayers[12].sprite = blankSprite;
                paperDollHandLayers[13].sprite = blankSprite;
                //currentToken.helmetSprite = 0;
                break;

            case 2: //tiefling
                //currentToken.helmetSprite = 0;
                break;

            default:
                break;



        }




    }

    public void UpdateRaceButtons()
    {

        int race = currentToken.raceType;

        switch (race) {

            case 0: //base
                chestButton.gameObject.SetActive(true);
                hornButton.gameObject.SetActive(false);
                tailButton.gameObject.SetActive(false);
                break;
            case 1: //dragonborn
                chestButton.gameObject.SetActive(false);
                hornButton.gameObject.SetActive(true);
                tailButton.gameObject.SetActive(false);
                break;
            case 2://tiefling
                chestButton.gameObject.SetActive(true);
                hornButton.gameObject.SetActive(true);
                tailButton.gameObject.SetActive(true);
                break;
            default:
                Debug.LogError("RaceType not vaild.");
                break;

        }

    }

    public void ResetPaperdollAndCurrentToken() {

        //OverrideCurrentToken(defaultToken);
        ApplyTokenToPaperdoll(defaultToken);

    }

    public void SetDefaultToken(int race) {

        defaultToken = defaultTokenBank.SearchTokenbyRace(race);

    }

    //used by the UI buttons on the button grid.  places the sprite represented on the grid onto the paperdoll at the active layer 
    public void SetButtonSpriteToPaperdoll(Button button) {

        //get the button sprite
        Image buttonImage = button.transform.GetChild(0).GetComponent<Image>(); // gets the sprite from the child object's image that actually holds the sprite we want.
        Sprite buttonSprite = buttonImage.sprite;

        //determines if we are currently in a sublayer parent, then manages that button's selection state
        if (DoesLayerContainSubLayers(paperDollLayers[activeLayer])) {

            SetButtonSeletionState(button);

        }


        //finds and holds index for this button on the grid
        int buttonIndex = 0;
        for (int i = 0; i < currentbuttonGridLength; i++) {

            if (buttonGrid[i] == button) {

                buttonIndex = i;

            }

        }

        //holds the image and name of the active layer
        //Sprite paperdollLayerSprite = paperDollLayers[activeLayer].sprite;
        string layerName = paperDollLayers[activeLayer].name.ToUpper(); //used in switch case so that we don't have to hard code in the numbers like we used to.  don't do that again.

        switch (layerName) {

            case "BODY": //layer

                paperDollLayers[activeLayer].sprite = buttonSprite; //sets the sprite of this button to the active layer
                TogglePressedStateAsGroup(button); //manages the toggled pressed states of all the buttons within buttonGrid as if they were a toggle group.

                //currentToken.bodyType = buttonIndex; //sets the body type based on the button's index.
                //Debug.Log("BodyType = " + currentToken.bodyType);

                break;

            case "CHEST": //layer
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);

                //currentToken.chestType = buttonIndex;
                //Debug.Log("ChestType = " + currentToken.chestType);

                break;

            case "HAIR": //layer
                paperDollLayers[activeLayer].sprite = buttonSprite;

                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                //currentToken.hairSprite = ReturnButtonSpriteNameID(button);
                //Debug.Log("HairSprite = " + currentToken.hairSprite);
                break;

            case "CLOTHING": //sublayer parent
                lastSelectedLayer = paperDollClothingLayers[buttonIndex]; //this button's index will be used to set the sublayer as the last selected layer.  for normal layers this is called in "SetActiveLayer"
                picker.CurrentColor = buttonImage.color; //sets the current color of the picker to the button's color for ease of editting.
                //an early break statement.  This allows the player to press an already pressed button so it's color can be editted.  
                if (WasButtonLastSelected(button) && IsButtonPressed(button)) {
                    break;
                }
                paperDollClothingLayers[buttonIndex].sprite = ReturnButtonSpriteAsToggle(button); //sets the button sprite to the approprate sub layer, then toggles this button accordingly.

                /*if(paperDollClothingLayers[buttonIndex].sprite == blankSprite)
                    currentToken.clothingSprites.Remove(ReturnButtonSpriteNameID(button));

                else
                    currentToken.clothingSprites.Add(ReturnButtonSpriteNameID(button));*/

                break;

            case "CAPE":
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                //currentToken.capeSprite = buttonIndex;

                //Debug.Log("CapeSprite = " + currentToken.capeSprite);
                break;

            case "BACK":
                Debug.Log("ActiveLayer = " + activeLayer);
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                //currentToken.backSprite = buttonIndex;

                //Debug.Log("BackSprite = " + currentToken.backSprite);
                break;

            case "SHOULDER":
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                //currentToken.shoulderSprite = buttonIndex;

                //Debug.Log("ShoulderSprite = " + currentToken.shoulderSprite);
                break;

            case "EQUIPMENT":

                lastSelectedLayer = paperDollEquipmentLayers[buttonIndex];
                picker.CurrentColor = buttonImage.color;
                if (WasButtonLastSelected(button) && IsButtonPressed(button))
                    break;
                paperDollEquipmentLayers[buttonIndex].sprite = ReturnButtonSpriteAsToggle(button);
                break;

            case "HANDS":

                lastSelectedLayer = paperDollHandLayers[buttonIndex];
                picker.CurrentColor = buttonImage.color;
                if (WasButtonLastSelected(button) && IsButtonPressed(button))
                    break;
                paperDollHandLayers[buttonIndex].sprite = ReturnButtonSpriteAsToggle(button);
                break;

            case "HORNS":

                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);

                //currentToken.hornSprite = buttonIndex;
                //Debug.Log("HornSprite = " + currentToken.hornSprite);
                break;

            case "TAIL":

                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);

                //currentToken.tailSprite = buttonIndex;
                //Debug.Log("TailSprite = " + currentToken.tailSprite);
                break;

            case "HELMET":
                paperDollLayers[activeLayer].sprite = buttonSprite;
                TogglePressedStateAsGroup(button);
                lastSelectedLayer = paperDollLayers[activeLayer];
                //currentToken.helmetSprite = buttonIndex;

                //Debug.Log("HelmetSprite = " + currentToken.helmetSprite);
                break;

            default:
                break;



        }

        //UpdatePaperDoll(currentToken);
        RefreshPaperdoll();

    }

    //used by UI button "Random".  assigns random values to sprites then uses UpdatePaperdoll to apply them.  Also uses set active layer to update button pressed states and colors.
    //does not randomize color yet.
    public void RandomizePaperdoll() {

        //body
        //bodyType = UnityEngine.Random.Range(0, bodyStrings.Length); //sets a random body type

        //hair 
        //currentToken.hairSprite = UnityEngine.Random.Range(0, spriteLibrary.GetSprites(ConstructKey("hairtypekey")).Length);


        //clothing
        Sprite[] clothingSprites = spriteLibrary.GetSprites(ConstructKey("clothingtypekey"));


        for (int i = 0; i < paperDollClothingLayers.Length; i++) {

            if (UnityEngine.Random.value < 0.5f)
                paperDollClothingLayers[i].sprite = clothingSprites[i];

            else
                paperDollClothingLayers[i].sprite = blankSprite;

        }

        //hands  this will stay commented out until we have more hand sprites.
        /*Sprite[] handSprites = spriteLibrary.GetSprites(ConstructKey("handtypekey"));

        int handCounter = 0;
        int maxHandSprites = 4;

        for (int i = 0; i < paperDollHandLayers.Length; i++)
        {

            if (Random.value < 0.5f)
            {
                paperDollHandLayers[i].sprite = handSprites[i];
                handCounter++;
            }
                
            else
                paperDollHandLayers[i].sprite = blankSprite;

            
            if (handCounter == maxHandSprites)
                break;
        }
        */

        //shoulder
        //currentToken.shoulderSprite = UnityEngine.Random.Range(0, spriteLibrary.GetSprites("shoulderTypeKey").Length);

        //back
        //currentToken.backSprite = UnityEngine.Random.Range(0, spriteLibrary.GetSprites("backtypekey").Length);


        //cape
        //currentToken.capeSprite = UnityEngine.Random.Range(0, spriteLibrary.GetSprites("capetypekey").Length);

        /*
        if (raceType == 1)
            hornSprite = UnityEngine.Random.Range(0, spriteLibrary.GetSprites("horntypekey").Length);

        if (raceType == 2) { 
        
            hornSprite = UnityEngine.Random.Range(0, spriteLibrary.GetSprites("horntypekey").Length);
            tailSprite = UnityEngine.Random.Range(0, spriteLibrary.GetSprites("tailtypekey").Length);
        }*/



        SetActiveLayer(paperDollLayers[activeLayer].name); //updates the buttons 


        ApplyTokenToPaperdoll(currentToken); //updates the paperdolls


    }

    int FindSpriteNumID(string spriteKey, string stringID) {

        int id = 0;

        Sprite[] sprites = spriteLibrary.GetSprites(spriteKey);

        for (int i = 0; i < sprites.Length; i++) {

            string spriteName = GetSpriteNameID(sprites[i]);

            if (spriteName == stringID)
                id = i;

        }

        return id;

    }

    Sprite ReturnSpriteFromNameID(string spriteKey, string stringID)
    {
        
        Sprite[] sprites = spriteLibrary.GetSprites(spriteKey);

        stringID = stringID.ToUpper();

        for (int i = 0; i < sprites.Length; i++)
        {

            string spriteName = GetSpriteNameID(sprites[i]);
            spriteName = spriteName.ToUpper();

            //Debug.Log("SpriteName : " + spriteName + " | stringID : " + stringID);

            if (spriteName == stringID)
                return sprites[i];

        }

        return blankSprite;

    }
    
    public void ApplyPaperdollToToken(Token token){

        token.baseLayers.Clear();
        token.subLayers.Clear();

        for (int i = 0; i < paperDollLayers.Length; i++) {
            PaperdollLayerObject layerObject = new PaperdollLayerObject(paperDollLayers[i]);
            //Debug.Log(layerObject.name + ", " + layerObject.spriteName);
            token.baseLayers.Add(layerObject);
        }

        for (int i = 0; i < paperDollClothingLayers.Length; i++)
            {

                PaperdollLayerObject layerObject = new PaperdollLayerObject(paperDollClothingLayers[i]);

                token.subLayers.Add(layerObject);
            }


        for (int i = 0; i < paperDollHandLayers.Length; i++)
        {

            PaperdollLayerObject layerObject = new PaperdollLayerObject(paperDollHandLayers[i]);

            token.subLayers.Add(layerObject);
        }

        for (int i = 0; i < paperDollEquipmentLayers.Length; i++)
        {

            PaperdollLayerObject layerObject = new PaperdollLayerObject(paperDollEquipmentLayers[i]);

            token.subLayers.Add(layerObject);
        }



    }
    
    //takes the paperdoll layer object from the token and applies sprite, color, and rotation to the appropriate paperdoll layer
    void SetLayerObjectProperitesToPaperDollLayer(PaperdollLayerObject layerObject, Image paperDollLayer) {

        string paperDollLayerName = paperDollLayer.name;
        paperDollLayer.sprite = ReturnSpriteFromNameID(ConstructKey(paperDollLayerName), layerObject.SpriteID);
        //Debug.Log("layer object sprite name: " + layerObject.spriteName);
        paperDollLayer.color = layerObject.color;
        paperDollLayer.rectTransform.localRotation = new Quaternion(0, layerObject.rotation, 0, 0);
        
    }

    void SetLayerObjectProperitesToPaperDollSubLayer(PaperdollLayerObject layerObject, string paperDollLayerName, Image paperDollSubLayer)
    {
        
        paperDollSubLayer.sprite = ReturnSpriteFromNameID(ConstructKey(paperDollLayerName), layerObject.SpriteID);
        paperDollSubLayer.color = layerObject.color;
        paperDollSubLayer.rectTransform.localRotation = new Quaternion(0, layerObject.rotation, 0, 0);

    }

    //called in SetSpriteToPaperdoll() and other UI buttons.  updates sprites that are dependant on other variables, such as race, body type, chest type, etc.
    public void ApplyTokenToPaperdoll(Token token) {

        //base layers
        PaperdollLayerObject currentLayerObject;
        
        for (int i = 0; i < paperDollLayers.Length; i++) {
            
            string paperDollLayerName = paperDollLayers[i].name;
            
            currentLayerObject = token.baseLayers.Find(x => x.name.Contains(paperDollLayerName));
            if (currentLayerObject != null) {
                SetLayerObjectProperitesToPaperDollLayer(currentLayerObject, paperDollLayers[i]);
                Debug.Log("current layer object name " + currentLayerObject.name);
            } //ensure object is found
                
           

            //else
            //Debug.LogError("Layer Object " + paperDollLayerName + " not found.");

        }
        
        //sub layers, searches by sprite name rather than sub layer name, since sub layers may change between races (i.e. claws vs arm wrap as base)
        Sprite[] clothingSprites = spriteLibrary.GetSprites(ConstructKey("Clothing"));
        Debug.Log("clothingSprite length: " + clothingSprites.Length);
        for (int i = 0; i < clothingSprites.Length; i++)
        {
            //Debug.Log("Sprite Name ID" + ReturnSpriteNameID(clothingSprites[i]));
            currentLayerObject = token.subLayers.Find(x => x.SpriteID.Contains(GetSpriteNameID(clothingSprites[i])));

            if (currentLayerObject == null)
                continue;

            if (currentLayerObject.SpriteID == GetSpriteNameID(clothingSprites[i]))
                SetLayerObjectProperitesToPaperDollSubLayer(currentLayerObject, "Clothing",  paperDollClothingLayers[i]);

            else
                paperDollClothingLayers[i].sprite = blankSprite;

        }

        Sprite[] handSprites = spriteLibrary.GetSprites(ConstructKey("Hands"));
        //Debug.Log("handSprite length" + handSprites.Length);
        for (int i = 0; i < handSprites.Length; i++)
        {
            //Debug.Log("Sprite Name ID" + ReturnSpriteNameID(handSprites[i]));
            currentLayerObject = token.subLayers.Find(x => x.SpriteID.Contains(GetSpriteNameID(handSprites[i])));


            if (currentLayerObject == null)
                continue;


            if (currentLayerObject.SpriteID == GetSpriteNameID(handSprites[i]))
                SetLayerObjectProperitesToPaperDollSubLayer(currentLayerObject, "Hands", paperDollHandLayers[i]);

            else
                paperDollHandLayers[i].sprite = blankSprite;

        }

        Sprite[] equipmentSprites = spriteLibrary.GetSprites(ConstructKey("Equipment"));
        //Debug.Log("equipmentSprite length" + equipmentSprites.Length);
        for (int i = 0; i < equipmentSprites.Length; i++)
        {
            //Debug.Log("Sprite Name ID" + ReturnSpriteNameID(equipmentSprites[i]));
            currentLayerObject = token.subLayers.Find(x => x.SpriteID.Contains(GetSpriteNameID(equipmentSprites[i])));


            if (currentLayerObject == null)
                continue;


            if (currentLayerObject.SpriteID == GetSpriteNameID(equipmentSprites[i]))
                SetLayerObjectProperitesToPaperDollSubLayer(currentLayerObject, "Equipment", paperDollEquipmentLayers[i]);

            else
                paperDollEquipmentLayers[i].sprite = blankSprite;

        }


        ResetLastSelectedLayer();
        
        /* int layer = 0;
         PaperdollLayerObject currentLayerObject;
         //update tail
         if (token.raceType == 2) //if tiefling, update
         {

             string paperDollLayerName = paperDollLayers[layer].name;
             currentLayerObject = token.baseLayers.Find(x => x.name.Contains(paperDollLayerName));
             SetLayerObjectProperitesToPaperDollLayer(currentLayerObject, paperDollLayers[layer]);

         }

         else //if base or dragonborn, leave blank
         {

             paperDollLayers[layer].sprite = blankSprite;
             token.tailSprite = 0;

         }

         //PaperdollLayerObject thisLayer = token.baseLayers.Find(x => x.name.Contains("Tail"));
         //Debug.Log("Test Layer Name = " + thisLayer.name);

         layer++;
         //update body based on race
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("bodytypekey"), token.bodyType);
         layer++;
         //update chest
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("chesttypekey"), token.chestType);
         layer++;
         //update clothes

         Sprite[] clothingSprites = spriteLibrary.GetSprites(ConstructKey("clothingtypekey"));
         //Debug.Log("clothingSprite length" + clothingSprites.Length);
         for (int i = 0; i < clothingSprites.Length; i++)
         {
             //Debug.Log("Sprite Name ID" + ReturnSpriteNameID(clothingSprites[i]));
             if (token.clothingSprites.Contains(GetSpriteNameID(clothingSprites[i])))
                 paperDollClothingLayers[i].sprite = clothingSprites[i]; 

             else
                 paperDollClothingLayers[i].sprite = blankSprite;

         }

         layer++;
         //update hands
         for (int i = 0; i < token.handSprites.Length; i++)
         {

             if (token.handSprites[i])
                 paperDollHandLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("handtypekey"), i);

             else
                 paperDollHandLayers[i].sprite = blankSprite;

         }
         layer++;
         //capes
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("capetypekey"), token.capeSprite);
         layer++;
         //update equipment
         for (int i = 0; i < token.equipmentSprites.Length; i++)
         {

             if (token.equipmentSprites[i])
                 paperDollEquipmentLayers[i].sprite = spriteLibrary.GetSprite(ConstructKey("equipmenttypekey"), i);

             else
                 paperDollEquipmentLayers[i].sprite = blankSprite;

         }
         layer++;
         //Back
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("backtypekey"), token.backSprite);
         layer++;
         //shoulders
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("shouldertypekey"), token.shoulderSprite);
         layer++;
         //update head based on race
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite("Heads", ConstructKey("headtypekey"));
         layer++;
         //update hair based on race
         int spriteNumID = FindSpriteNumID(ConstructKey("hairtypekey"), token.hairSprite);
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("hairtypekey"), spriteNumID);
         layer++;
         //update horns
         if (token.raceType == 0)//if base creature, leave blank
         {

             paperDollLayers[layer].sprite = blankSprite;
             token.hornSprite = 0;

         }

         else { //if dragonborn or tiefling, update

             paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("horntypekey"), token.hornSprite);

         }
         layer++;
         //update helmet based on race
         paperDollLayers[layer].sprite = spriteLibrary.GetSprite(ConstructKey("helmettypekey"), token.helmetSprite);

         //update colors for colored Layers
         /*for (int i = 0; i < paperDollLayers.Length; i++)
         {
             paperDollLayers[i].color = token.layerColors[i];
             paperDollLayers[i].rectTransform.localRotation = new Quaternion(0, token.layerRotations[i], 0, 0);
         }


         for (int i = 0; i < paperDollClothingLayers.Length; i++)
         {
             paperDollClothingLayers[i].color = token.clothingLayerColors[i];
             paperDollClothingLayers[i].rectTransform.localRotation = new Quaternion(0, token.clothingLayerRotations[i], 0, 0);
         }


         for (int i = 0; i < paperDollHandLayers.Length; i++)
         {
             paperDollHandLayers[i].color = token.handLayerColors[i];
             paperDollHandLayers[i].rectTransform.localRotation = new Quaternion(0, token.handLayerRotations[i], 0, 0);
         }

         for (int i = 0; i < paperDollEquipmentLayers.Length; i++)
         {
             paperDollEquipmentLayers[i].color = token.equipmentLayerColors[i];
             paperDollEquipmentLayers[i].rectTransform.localRotation = new Quaternion(0, token.equipmentLayerRotations[i], 0, 0);
         }

        ResetLastSelectedLayer();*/

    }


    void RefreshPaperdoll() {

        for (int i = 0; i < paperDollLayers.Length; i++)
        {

            paperDollLayers[i].sprite = ReturnSpriteFromNameID(ConstructKey(paperDollLayers[i].name), GetSpriteNameID(paperDollLayers[i]));
            
        }

        for (int i = 0; i < paperDollClothingLayers.Length; i++)
        {

            paperDollClothingLayers[i].sprite = ReturnSpriteFromNameID(ConstructKey("Clothing"), GetSpriteNameID(paperDollClothingLayers[i]));

        }

        for (int i = 0; i < paperDollHandLayers.Length; i++)
        {

            paperDollHandLayers[i].sprite = ReturnSpriteFromNameID(ConstructKey("Hands"), GetSpriteNameID(paperDollHandLayers[i]));

        }

        for (int i = 0; i < paperDollEquipmentLayers.Length; i++)
        {

            paperDollEquipmentLayers[i].sprite = ReturnSpriteFromNameID(ConstructKey("Equipment"), GetSpriteNameID(paperDollEquipmentLayers[i]));

        }


    }


    //updates the color of all the layers dependant on skin color, such as body, chest, and head.  skinLayer is the first object in the skinLayers array.
    void UpdateSkinColor() {

        //skinColor = skinLayer.color;
        Color previousSkinColor = skinColor;

        //check to see if the last selected layer is a skin layer
        for (int i = 0; i < skinLayers.Length; i++)
        {

            if (skinLayers[i] == lastSelectedLayer)
                skinColor = lastSelectedLayer.color;

        }

        //update all the skin layers to be the same color in real time if the skin color changed.
        if (previousSkinColor != skinColor) {

            for (int i = 0; i < skinLayers.Length; i++)
            {

                skinLayers[i].color = skinColor;

            }

        }
       
        
    }
    
    //changes the scale of the paperdoll for closer inspection by the player.  called by UI elements
    public void ResizePaperdoll(int resize)
    {
        paperDoll.transform.localScale = new Vector3(resize, resize, resize);
    }
    
    //for use of Mirror button in UI.  flips the image across the y axis as a toggle
    public void MirrorLayer() {
        
        float currentRotation = lastSelectedLayer.rectTransform.localRotation.y;
        
        if (currentRotation == 0)
            lastSelectedLayer.rectTransform.localRotation = new Quaternion(0, 180, 0, 0);

        else
            lastSelectedLayer.rectTransform.localRotation = new Quaternion(0, 0, 0, 0);
        
    }

    #endregion
    
    #region Button Grid Methods

    //called in Start(). defines the buttonGrid
    void SetUpButtons()
    {

        buttonGrid = gridObject.transform.GetComponentsInChildren<Button>();

    }

    //activates the appropriate number of buttons needed, applying the appropriate sprite dictated by the sprite library
    void FillButtons(string filePath) {
        //gets the sprites from the library
        Sprite[] sprites = spriteLibrary.GetSprites(filePath);
        //activates the appropriate number of buttons on the grid.
        if (currentbuttonGridLength < sprites.Length) {

            for (int i = currentbuttonGridLength; i < sprites.Length; i++) {

                buttonGrid[i].gameObject.SetActive(true);

            }

        }
        //updates the image o the buttons to be those from the sprite library
        for (int i = 0; i < sprites.Length; i++)
        {

            //set sprite
            Image buttonImage = buttonGrid[i].transform.GetChild(0).GetComponent<Image>(); //requires get child, as the buttons in the grid hold a child object with the image component.  this component is the one we apply the sprites to.
            
            buttonImage.sprite = sprites[i];

        }
        //deactivates any un-needed buttons
        for (int i = sprites.Length; i < buttonGrid.Length; i++)
        {

            buttonGrid[i].gameObject.SetActive(false);

        }
        //updates the current length of the button grid.  
        currentbuttonGridLength = sprites.Length;
        
    }

    //resizes images on the button grid.  when increasing size the sprites would shift and the last part of this method helps normalize that.
    void ResizeButtonGridSprites(int resize) {

        for (int i = 0; i < currentbuttonGridLength; i++) {

            Image buttonImage = buttonGrid[i].transform.GetChild(0).GetComponent<Image>();
                
            buttonImage.transform.localScale = new Vector3(resize, resize, resize); //changes the scale of the image

            float repos = resize - 1; //for resize 1, this will create a reposition vector of o,o,o.  

            buttonImage.rectTransform.position = Vector3.zero;  

            //the following is for the hands layer, which requires that the even images be centered more to the right with the odd images to the left
            if (i % 2 == 0 || i == 0) {
                float x = repos * 30.0f;
                buttonImage.transform.localPosition = new Vector3(x, 0, 0);
            }
            
            else {
                float x = repos * -30.0f;
                buttonImage.transform.localPosition = new Vector3(x, 0, 0);
            }
               
        }

    }

    //changes the number of columns in the grid
    void ChangeFixedColumnCount(int size) {

        gridObject.GetComponent<GridLayoutGroup>().constraintCount = size;
        
    }

    //manages the button's selection state between inactive (not pressed), active (pressed), and selected (being edited by the color picker)
    void SetButtonSeletionState(Button button) {

        if (IsButtonPressed(button) && WasButtonLastSelected(button))
        {

            lastSelectedButton = emptyButton;
            selector.ResetSelector();

        }

        else if (IsButtonPressed(button) && !WasButtonLastSelected(button))
        {

            lastSelectedButton = button;
            selector.SelectThis(button.GetComponent<RectTransform>());


        }

        else if (!IsButtonPressed(button)) {

            lastSelectedButton = button;
            selector.SelectThis(button.GetComponent<RectTransform>());


        }

        //Debug.Log("Last Selected Button was " + button.name);

    }
    
    //checks if the button passed through the method equals the lastSelectedButton, and if so returns true
    bool WasButtonLastSelected(Button button) {

        if (lastSelectedButton == button)
            return true;
        
        else
            return false;
        
    }
    
    //called in Update(), this updates the colors of the buttons.  
    void UpdateButtonColor() {
        
        bool isSubLayer = DoesLayerContainSubLayers(paperDollLayers[activeLayer]);

        //check see if the active layer contains sublayers

        Image[] layers = ReturnActiveLayers();
        
        if (isSubLayer) // if the active layer is a sublayer, then only update the last selected button.  this is used for clothing, hands, and other layers that contain sublayers
        {
            lastSelectedButton.transform.GetChild(0).GetComponent<Image>().color = lastSelectedLayer.color;
        }
           
        
        else{ //if the active layer is not a sublayer, then update all the buttons on the grid.  this is used for body, hair, capes, etc
            
            for (int i = 0; i < currentbuttonGridLength; i++)
            {

                buttonGrid[i].transform.GetChild(0).GetComponent<Image>().color = layers[activeLayer].color;

            }

        }
        
    }

    //places a button in a pressed state if the type of that item is currently active on the paperdoll.  then places the rest of the buttons into the unpressed state
    void SetButtonPressedState(int type) {
        
        if (paperDollLayers[activeLayer].gameObject.activeSelf)
        {
            
            for (int i = 0; i < currentbuttonGridLength; i++)
            {

                if (i == type)
                {

                    buttonGrid[i].image.color = buttonGrid[i].colors.pressedColor;
                    
                }

                else {

                    buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

                }

            }

        }

        else {


            for (int i = 0; i < currentbuttonGridLength; i++)
            {

               buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

            }

        }



    }

    //places a button in a pressed state if the type of that item is currently active on the paperdoll.  then places the rest of the buttons into the unpressed state
    void SetButtonPressedState(string spriteNameID)
    {

        if (paperDollLayers[activeLayer].gameObject.activeSelf)
        {

            for (int i = 0; i < currentbuttonGridLength; i++)
            {

                if (ReturnButtonSpriteNameID(buttonGrid[i]) == spriteNameID)
                {

                    buttonGrid[i].image.color = buttonGrid[i].colors.pressedColor;

                }

                else
                {

                    buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

                }

            }

        }

        else
        {


            for (int i = 0; i < currentbuttonGridLength; i++)
            {

                buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

            }

        }



    }

    //overload method that takes an array rather than a single interger.
    void SetButtonsPressedStates(int[] types)
    {
        //sets all buttons into an unpressed state
        for (int i = 0; i < currentbuttonGridLength; i++)
        {

            buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;

        }
        //then presses the ones that are currently active on the paperdoll
        for (int i = 0; i < types.Length; i++) {

            buttonGrid[types[i]].image.color = buttonGrid[types[i]].colors.pressedColor;

        }

    }

    //checks if the button is in the pressed state, returning true if it is.
    bool IsButtonPressed(Button button) {

        if (button.image.color == button.colors.pressedColor)
            return true;
        
        else
            return false;
            
    }
    
    //this will return the sprite associated with the button passed through this method.  It will also toggle it's pressed state.
    Sprite ReturnButtonSpriteAsToggle(Button button)
    {

        Sprite buttonSprite = button.transform.GetChild(0).GetComponent<Image>().sprite; // gets the sprite from the child object's image that actually holds the sprite we want.

        //checks to see if the button is not yet pressed.  if the button is normal color (not pressed) apply the button's sprite and change it to pressed color;
        if (!IsButtonPressed(button))
        {

            button.image.color = button.colors.pressedColor;
            return buttonSprite;

        }
        //if button was already pressed and active, toggle it back to the normal color and return a blank sprite.
        else
        {

            button.image.color = button.colors.normalColor;
            return blankSprite;

        }

    }

    string ReturnButtonSpriteNameID(Button button)
    {

        Sprite buttonSprite = button.transform.GetChild(0).GetComponent<Image>().sprite; // gets the sprite from the child object's image that actually holds the sprite we want.

        string name = buttonSprite.name;

        string[] nameSplit = name.Split('_');

        string clean = nameSplit[nameSplit.Length - 1]; //gives us the last item in the array, which should be the name of the sprite w/o body, size, or other qualifiers.
        
        return clean;
    }
    
    string ReturnPaperDollLayerSpriteNameID(Image layer) {
        
        Sprite sprite = layer.sprite;

        string name = sprite.name;

        string[] nameSplit = name.Split('_');

        string clean = nameSplit[nameSplit.Length - 1]; //gives us the last item in the array, which should be the name of the sprite w/o body, size, or other qualifiers.

        return clean;

    }

    //toggles between pressed and normal states.
    void TogglePressedState(Button button)
    {

        //checks to see if the button is not yet pressed.  if the button is normal color (not pressed) apply the button's sprite and change it to pressed color;
        if (!IsButtonPressed(button))
            button.image.color = button.colors.pressedColor;
            
        //if button was already pressed and active, toggle it back to the normal color and return a blank sprite.
        else
            button.image.color = button.colors.normalColor;
            
    }

    //toggles a set of buttons as a group, ensuring only one button is pressed from the group at a time. similar to a toggle group component
    void TogglePressedStateAsGroup(Button button)
    {
        
        for (int i = 0; i < buttonGrid.Length; i++){

            if (buttonGrid[i] == button) { //looks for the button within the grid, making sure it is in the pressed state
                
                buttonGrid[i].image.color = buttonGrid[i].colors.pressedColor;
                selector.SelectThis(buttonGrid[i].GetComponent<RectTransform>());


            }

            else
            {// sets the rest of the buttons in the grid that are not the target button to normal color (unpressed)

                buttonGrid[i].image.color = buttonGrid[i].colors.normalColor;
                
            }


        }

    }

    //sets last selectedbutton to emptyButton
    void ResetButtonSelection() {

        lastSelectedButton = emptyButton;

    }
    
    //Used by catagory buttons in UI to apply colors from the layer to the appropriate buttons.
    void SetLayerColorstoButtonGrid(Image layer)
    {

        for (int i = 0; i < buttonGrid.Length; i++)
        {

            buttonGrid[i].transform.GetChild(0).GetComponent<Image>().color = layer.color;

        }

    }

    //overloaded for SubLayers
    void SetLayerColorstoButtonGrid(Image[] layers) {

        for (int i = 0; i < layers.Length; i++) {

            buttonGrid[i].transform.GetChild(0).GetComponent<Image>().color = layers[i].color;
            
        }

    }
   
    //sets all the buttons in the button grid to white
    void ResetColorsOnButtonGrid() {


        for (int i = 0; i < buttonGrid.Length; i++)
        {

            Image buttonImage = buttonGrid[i].transform.GetChild(0).GetComponent<Image>();
            buttonImage.color = Color.white;

        }

    }

    //sets all buttons on the buttonGrid to be inactive
    public void DeactivateAllButtons() {

        for (int i = 0; i < buttonGrid.Length; i++){

            buttonGrid[i].gameObject.SetActive(false);

        }

        currentbuttonGridLength = 0;

    }

    #endregion

    #region Token Methods

    //replaces the current token's data with the given token.
    /*public void OverrideCurrentToken(Token token) {

        if (token == null) {return;}
        
        currentToken.ChangeTokenName(token.tokenName);
        currentToken.ChangeTokenRace(token.raceID);

        currentToken.size = token.size;
        currentToken.chestType = token.chestType;
        currentToken.raceType = token.raceType;
        currentToken.bodyType = token.bodyType;
        currentToken.head = token.head;

        currentToken.baseLayers.

        //for each sublayer, it goes through the list of sprites and applies tokens
        /*for (int i = 0; i < token.clothingSprites.Length; i++) {

            currentToken.clothingSprites[i] = token.clothingSprites[i];
            currentToken.layerColors[i] = token.layerColors[i];
            currentToken.layerRotations[i] = token.layerRotations[i];

        }
        
        
        ResetLastSelectedLayer();
        
    }*/

    #endregion


    public void SaveToken() {

        ApplyPaperdollToToken(currentToken);
        datamanger.SaveToken(currentToken);
        
    }


    public void LoadToken() {

        TokenData newData = datamanger.ReturnTokenData();
        
        currentToken = tokenBank.SearchTokenbyRace(newData.raceID);

        Debug.Log("newtoken: " + currentToken.name);
        currentToken.ClearAllLayers();
        datamanger.LoadToken(currentToken);
        
        ApplyTokenToPaperdoll(currentToken);
        RefreshPaperdoll();

    }

    // Use this for initialization
    void Start () {
        
        SetUpButtons();

        SetUpColorPicker();

        ResetButtonSelection();

        ResetLastSelectedLayer();

        //sets our paperdoll layer arrays
        paperDollLayers = ReturnImagesFromTag("PaperdollLayer");
        paperDollBodyLayer = paperDollLayers[1];
        paperDollChestLayer = paperDollLayers[2];
        paperDollClothingLayers = ReturnImagesFromTag("PaperdollSubLayer", paperDollLayers[3]);
        paperDollHandLayers = ReturnImagesFromTag("PaperdollSubLayer", paperDollLayers[4]);
        paperDollEquipmentLayers = ReturnImagesFromTag("PaperdollSubLayer", paperDollLayers[6]);

        //skinLayer = skinLayers[0]; //skinLayer only needs to be set to any of the skin layers

        skinColor = skinLayers[0].color;

        for (int i = 0; i < paperDollLayers.Length; i++) {
            //Debug.Log(paperDollLayers[i].name + ": " + i);
        }
           
       

        if (datamanger.FileName != "") {
            datamanger.LoadToken(currentToken);
            datamanger.FileName = "";
        }


        //OverrideCurrentToken(currentToken);
        
        DeactivateAllButtons();

        ApplyTokenToPaperdoll(currentToken);



       
      
}
	
	// Update is called once per frame
	void Update () {

        UpdateButtonColor();
        UpdateActiveLayerColor();
        UpdateSkinColor();
        //UpdatePaperDoll(); <- this is no longer called in update, but instead called as needed by SetSpriteToPaperDoll and other UI buttons

        
    }
}
